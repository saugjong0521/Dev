<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <script>
        
        /*
        화살표 함수
        es6에 새로 추가된 함수 표현식
        */

        //기본적인 함수 표현식
        test01() // 호이스팅 가능
        
        function test01(){
            console.log('test01')
        }

        test01()


        //변수 선억식
        // test02() -> Cannot access 'test02' before initialization  // 호이스팅 불가 (let으로 시작되기에)
        let test02 = function(){
            console.log('test02')
        }
        test02() // 변수명으로 호출

        //새로 추가된 화살표 함수
        // test03() -> test03 is not defined  // 호이스팅 불가
        test02 = () => {
            console.log('test03')
        }
        test03()


        let test04 = () => console.log('test04')
        test04()
        // 출력할 코드가 하나라면 코드블럭 생략이 가능해 훨씬 간편함


        let test05 = (a) => console.log(a * a);
        test05(5) // 25


        let test06 = a => console.log(a * a);
        test06(6)
        // 매개변수가 하나라면, ()가 생략되도 된다.
        // 화살표 함수로는 생성자 함수를 만들 수 없다.
        // 이유는 this와 바인딩 protype의 특성과 관련이 있기 때문

        function Person(name) {
            this.name = name;
        }

        const kim = new Person('kim');
        console.log(kim.name)

        let Person01 = (name) => {
            this.name = name
        }
        const park = new Person01('park');
        console.log(park.name)//TypeError: Person01 is not a constructor

        //화살표 함수에서의 this는 전역 객체를 참조하거나 undefinde

        /*
        일반 함수에서의 this는 함수가 호출할때의 컨텍스트에 따라서 동적으로 결정된다.
        즉 호출하는 방식에 따라서 this의 선택자가 달라지게 된다.

        화살표 함수에서의 this는 자기 자신만의 this를 가지지 않고, 정해진 컨텍스트의 this만 참조하도록 설계되어 있다.
        화살표 함수는 호출된 위치의 this를 그대로 사용하기 때문에 인스턴스의 this를 참조하지 못하게 된다.


        
        */


    </script>
    
</head>

<body>

</body>

</html>