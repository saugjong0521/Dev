<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed, 
figure, figcaption, footer, header, hgroup, 
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
	margin: 0;
	padding: 0;
	border: 0;
	font-size: 100%;
	font: inherit;
	vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure, 
footer, header, hgroup, menu, nav, section {
	display: block;
}
body {
	line-height: 1;
}
ol, ul {
	list-style: none;
}
blockquote, q {
	quotes: none;
}
blockquote:before, blockquote:after,
q:before, q:after {
	content: '';
	content: none;
}
table {
	border-collapse: collapse;
	border-spacing: 0;
}


.global-container{
    background-color: #e9e9e7;
    width: 100vw;
    height: 100vh;
    display: flex;
    justify-content: center;
    overflow: hidden;
    
}

.drawingArea{
    width: 95vw;
    height: 85vh;
    background-color: #fff;
    /* margin: 10vh auto 0; */
    align-self: self-start;
    border: solid 2px purple;
    border-radius: 20px;
    box-sizing: content-box;
    margin-top: 20px;
}


/* 세팅 */
.settingArea{
    position: fixed;
    display: flex;
    bottom: 0;
    width: 100vw;
    height: 10vh;
    background-image: linear-gradient(to top, #d5d4d0 0%, #d5d4d0 1%, #eeeeec 31%, #efeeec 75%, #e9e9e7 100%);
    justify-content: center;
    align-items: center;
    border: solid 1px black;
}

    /* 로고 영역 */
    .logo{
        width: 100px;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6);
        margin-right: 5%;
        display: flex;
        justify-content: center;
        align-items: center;
        /* background-image: ; */
    }


    /* 컬러 바 */
    .color-pallete{
        display: flex;
        flex-wrap: wrap;
        width: 50%;
        height: 100%;
        justify-content: center;
        align-items: center;
        gap: 10px;
    }

        .colors{
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: block;
        }

        .more-color-box{
            width: 6%;
            height: 80%;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            border: solid 1px #000;
            color: black;
        }
        .more-color-theme{
            display: flex;
            width: 100%;
            align-items: center;
            justify-content: center;
        }
        
        .more-color-contents{
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

            .color-input{
                width: 50px;
                height: 50px;
                border-radius: 50%;
                border: none;
                padding: 0;
                margin: 0;
                cursor: pointer;
            }
            .color-input::-webkit-color-swatch{
                border-radius: 50%;
                border: none;
            }

            .more-color-btn{
                width: 20px;
                height: 40px;
                background-color: green;
                display: flex;
                justify-content: center;
                align-items: center;
                text-align: center;
            }
    


    /* 굵기 바 */
    .thicknessBox{
        display: flex;
        margin: auto;
        justify-content: center;
        align-items: center;
        width: 20%;
        height: 100%;
        padding: 0 10px; /* 좌우 패딩 */
        box-sizing: border-box;
        flex-direction: column;
        gap: 20px;
    }

        .thickness-name{
            font-size: 24px;
            font-weight: 700;
        }

        .thickness{
            width: 80%;
            margin: 0;
            box-sizing: border-box;
        }

    /* 리셋 버튼*/
    .undoBtn{
        display: flex;
        width: 80px;
        height: 80px;
        border-radius: 50%;
        background-color: skyblue;
        justify-content: center;
        align-items: center;
        margin: auto;
        border: solid 3px black;
    }

        

    /* 리셋 버튼*/
    .clearBtn{
        display: flex;
        width: 80px;
        height: 80px;
        border-radius: 50%;
        background-color: aquamarine;
        justify-content: center;
        align-items: center;
        margin: auto;
        border: solid 3px black;
    }

    /* 저장 버튼*/
    .saveBtn{
        display: flex;
        width: 80px;
        height: 80px;
        border-radius: 50%;
        background-color: tomato;
        justify-content: center;
        align-items: center;
        margin: auto;
        border: solid 3px black;
    }


</style>
<body>
    <div class="global-container">
        <div class="drawingArea">
            <canvas id="drawing"></canvas>
        </div>

        <div class="settingArea">
            <div class="logo">LOGO</div>
            <div class="color-pallete"></div>
            <div class="more-color-box">
                <div class="more-color-theme">다른 색상</div>
                <div class="more-color-contents">
                    <input type="color" class="color-input">
                    <div class="more-color-btn">저장</div>
                </div>
            </div>
            
            
            <div class="thicknessBox">
                <div class="thickness-name">굵기 조절</div>
                <input class="thickness" type="range" min="1" max="10" step="0.5">
            </div>
            <div class="undoBtn">Undo</div>
            <div class="clearBtn">리셋</div>
            <div class="saveBtn">저장</div>
        </div>
    </div>



    <script>
window.onload = () => {
    resizeCanvas();  // 캔버스 크기 설정
    drawing();       // 그리기 함수 호출
    makecolor();
}

// 캔버스 크기 조정
function resizeCanvas() {
    const canvas = document.querySelector('#drawing');
    const drawingArea = document.querySelector('.drawingArea');
    canvas.width = drawingArea.clientWidth;
    canvas.height = drawingArea.clientHeight;
}

function drawing() {
    const canvas = document.querySelector('#drawing');
    const ctx = canvas.getContext('2d');
    let drawing = false;
    let color = 'black';  // 기본 색상
    let brush = 1;  // 기본 브러시 굵기
    let startX, startY;
    let drawingHistory = [];
    let currentStep = -1;
    let currentPath = [];
    let isDrawing = false;

    // 좌표 추출 (마우스/터치 구분)
    function getCoordinates(e) {
        const rect = canvas.getBoundingClientRect();
        if (e.type.startsWith('touch')) {
            const touch = e.touches[0] || e.changedTouches[0];
            return [
                (touch.clientX - rect.left) * (canvas.width / rect.width),
                (touch.clientY - rect.top) * (canvas.height / rect.height)
            ];
        } else {
            return [e.offsetX, e.offsetY];
        }
    }

    // 그리기 시작
    function startDrawing(e) {
        isDrawing = true;
        [startX, startY] = getCoordinates(e);
        currentPath = [{x: startX, y: startY}];
    }

    // 그리는 동안
    function moveDrawing(e) {
        if (!isDrawing) return;
        const [endX, endY] = getCoordinates(e);
        drawLine(ctx, startX, startY, endX, endY);
        currentPath.push({x: endX, y: endY});
        [startX, startY] = [endX, endY];
    }

    // 그리기 종료
    function stopDrawing() {
        if (!isDrawing) return;
        isDrawing = false;
        saveState();
    }

    // 선을 그리는 함수
    function drawLine(context, x1, y1, x2, y2) {
        drawThickness();
        context.strokeStyle = color;  // 현재 선택된 색상
        context.lineWidth = brush * 3;  // 선 두께 설정
        context.lineCap = "round";  // 선 끝을 둥글게
        context.beginPath();
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
        context.stroke();
        context.closePath();
    }

    // 이벤트 리스너 추가
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', moveDrawing);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);
    
    canvas.addEventListener('touchstart', startDrawing);
    canvas.addEventListener('touchmove', moveDrawing);
    canvas.addEventListener('touchend', stopDrawing);
    

    // 색상 변경 처리
    function changeColor() {
        const colorItems = document.querySelectorAll('.colors');
        colorItems.forEach(item => {
            item.addEventListener('click', () => {
                color = window.getComputedStyle(item).getPropertyValue('background-color');
            });
        });
    }

    // 굵기 변경 처리
    function drawThickness() {
        const brushItem = document.querySelector('.thickness');
        brush = brushItem ? brushItem.value : 1;
    }

    // 리셋 처리
    function resetCanvas() {
        const resetBtn = document.querySelector('.clearBtn');
        resetBtn.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawingHistory = [];
            currentStep = -1;
            saveState();
        });
    }

    function saveState() {
        if (currentPath.length > 1) {
            currentStep++;
            if (currentStep < drawingHistory.length) {
                drawingHistory.length = currentStep;
            }
            drawingHistory.push({
                path: currentPath.slice(),
                color: color,
                brush: brush
            });
        }
        currentPath = [];
    }

    function undo() {
        if (currentStep >= 0) {
            currentStep--;
            redrawCanvas();
        }
    }

    function redrawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i <= currentStep; i++) {
            const state = drawingHistory[i];
            ctx.strokeStyle = state.color;
            ctx.lineWidth = state.brush * 3;
            ctx.lineCap = "round";
            ctx.beginPath();
            ctx.moveTo(state.path[0].x, state.path[0].y);
            for (let j = 1; j < state.path.length; j++) {
                ctx.lineTo(state.path[j].x, state.path[j].y);
            }
            ctx.stroke();
        }
    }

    changeColor();  // 색상 변경 적용
    resetCanvas();  // 리셋 버튼 설정
    const undoBtn = document.querySelector('.undoBtn');
    undoBtn.addEventListener('click', undo);

    // 초기 상태 저장 제거
    // saveState();
}

//캔버스 저장 처리
document.querySelector('.saveBtn').addEventListener('click', () => {
    const canvas = document.querySelector('#drawing');
    const dataURL = canvas.toDataURL('image/png');
    const base64Data = dataURL.replace(/^data:image\/png;base64,/, "");

    fetch('/upload', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            image: base64Data,
        }),
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('네트워크 응답이 좋지 않습니다.');
        }
        return response.json();
    })
    .then(data => {
        console.log('Success:', data);
        window.location.href = '/question';
    })
    .catch((error) => {
        console.error('Error:', error);
    });
});


function makecolor(){
// 컬러팔레트 설정
const pallete = document.querySelector('.color-pallete');
const colorSet = [
    "#000000", "#FFFFFF", "#FF5733", "#FFC300", "#DAF7A6", "#FF33FF", "#33FF57", "#3380FF", "#FF9966", 
    "#FF6347", "#FF4500", "#FF1493", "#FFD700", "#FFA500", "#FF8C00", "#32CD32", "#00FF7F", "#228B22", 
    "#1E90FF", "#0000FF", "#00BFFF", "#8A2BE2", "#9370DB", "#800080", "#A52A2A", "#8B4513", "#D2691E", 
    "#B22222", "#FFB6C1", "#FF69B4", "#ADFF2F", "#7FFF00", "#F0E68C", "#FFDEAD", "#5F9EA0", "#4682B4", 
    "#4169E1", "#87CEFA", "#C71585", "#FF00FF", "#40E0D0"
];

// 컬러 팔레트 생성
function ColorPalette(pallete, colors) {
    colors.forEach(color => {
        let colorDiv = document.createElement("div");
        colorDiv.classList.add("colors");
        colorDiv.style.backgroundColor = color;
        pallete.appendChild(colorDiv);
    });
}
ColorPalette(pallete, colorSet);

// 컬러 팔레트 추가

const colorInput = document.querySelector('.color-input')
const colorInputBtn = document.querySelector('.more-color-btn')
colorInputBtn.addEventListener('click', addColor)

function addColor (){    
    const newColor = colorInput.value;
    colorSet.push(newColor)

    let colorDiv = document.createElement("div");
    colorDiv.classList.add("colors");
    colorDiv.style.backgroundColor = newColor;
    pallete.appendChild(colorDiv);

    colorDiv.addEventListener('click', () => {
        color = newColor;

    });
    changeColor();

}
}

    </script>


</body>
</html>
